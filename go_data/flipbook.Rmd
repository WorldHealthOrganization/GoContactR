---
title: "wrangling"
subtitle: ""
output:
  xaringan::moon_reader:
    self_contained: true
    css: ["default", "assets/sydney-fonts.css", "assets/sydney.css"]
    nature:
      ratio: 16:9
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
      navigation:
        scroll: false
---

```{css, echo = FALSE}
pre {
  overflow-x: scroll;
  max-height: 60vh;
  overflow-y:scroll;
}
.remark-slide-content {
    font-size: 18px
}

```



```{r, include = F}


knitr::opts_chunk$set(fig.width = 6, message = FALSE, warning = FALSE, comment = "", cache = F)
library(flipbookr)
library(tidyverse)

options(tibble.print_max = 35, tibble.print_min = 35)


###################################################################################################

url <- "https://godata-r13.who.int/"                   # <--------------------- insert instance url here, don't forget the slash at end !
username <- "godata_api@who.int"                           # <--------------------- insert your username for signing into Go.Data webapp here
password <- "godata_api@who"                           # <--------------------- insert your password for signing into Go.Data webapp here
outbreak_id <- "3b5554d7-2c19-41d0-b9af-475ad25a382b"   # <--------------- insert your outbreak ID here! (find it in URL when you have selected outbreak)

###################################################################################################

# SCRIPT TO PULL IN COLLECTIONS ACROSS ANY GO.DATA INSTANCE #

###################################################################################################
# read in from Go.Data API, using your updated log-in credentials by Clicking "Source"
# no need to modify the below unless you would like to bring in additional API endpoints used in the dashboards in webapp, etc!
# Script authored and maintained by Go.Data team (godata@who.int): Sara Hollis (holliss@who.int); James Fuller (fullerj@who.int)
###################################################################################################

# this script currently returns: 
#                                     cases, 
#                                     contacts,
#                                     contacts of contacts,
#                                     events
#                                     follow ups, 
#                                     lab results,
#                                     locations,
#                                     relationships,
#                                     teams,
#                                     users

###################################################################################################
# source required scripts, including packages that need to be installed
#       this includes set_core_fields.R script, which ensures that collections have all the columns they need and set to NA those that don't exist
#       otherwise, the JSON drops it if these questions were consistently not answered, which can break the scripts if its a core variable
###################################################################################################

source(here::here("go_data/scripts", "aaa_load_packages.R"))
source(here::here("go_data/scripts", "set_core_fields.R"))

###################################################################################################
# get access token
###################################################################################################

url_request <- paste0(url,"api/oauth/token?access_token=123")

response <- httr::POST(url=url_request,  
                 body = list(
                   username = username,                                          
                   password = password),                                       
                 encode = "json")

content <-
  httr::content(response, as = "text") %>%
  jsonlite::fromJSON(flatten = TRUE) %>%
  glimpse()

access_token <- content$access_token                 ## this is your access token !!! that allows API calls


###################################################################################################
# specify date ranges, for follow up filters - if your volume of follow up gets too large 
#     see below commented out code in Follow Ups section for an example
#     date_now <- format(Sys.time(), "%Y-%m-%dT23:59:59.999Z")                  
#     date_21d_ago <- format((Sys.Date()-21), "%Y-%m-%dT23:59:59.999Z")
###################################################################################################

###################################################################################################
# IMPORT ALL RELEVANT API COLLECTIONS BELOW 
###################################################################################################

# import contact follow-ups (could filter last 21 days only to avoid system time-out)
response_followups <- 
  httr::GET(paste0(url,
             "api/outbreaks/",
             outbreak_id,
             "/follow-ups"
             # /?filter={%22where%22:{%22and%22:[{%22date%22:{%22between%22:[%22",
             # date_21d_ago,
             # "%22,%22",
             # date_now,
             # "%22]}}]}}"
  ),
  httr::add_headers(Authorization = paste("Bearer", access_token, sep = " ")))

json_followups <- httr::content(response_followups, as="text")
followups <- as_tibble(jsonlite::fromJSON(json_followups, flatten = TRUE)) 
rm(response_followups)


# import oubtreak Contacts 
response_contacts <- httr::GET(paste0(url,"api/outbreaks/",outbreak_id,"/contacts"), 
                         add_headers(Authorization = paste("Bearer", access_token, sep = " "))
)
json_contacts <- httr::content(response_contacts, as = "text")
contacts <- as_tibble(jsonlite::fromJSON(json_contacts, flatten = TRUE))
rm(response_contacts)
```

```{r}
input <- list()
input$date_of_review <- as.Date("2020-07-01")
```


---


`r chunk_reveal("contacts_followups")`

```{r contacts_followups, include = FALSE}
todays_date <- input$date_of_review

todays_date

contacts %>% 
  select(id, dateOfLastContact) %>% 
  left_join(followups, by = c("id" = "contact.id")) %>% 
  select(id, dateOfLastContact, 
         dateOfFollowUp = date, statusId) %>% 
  ## convert dates to date
  mutate(across(matches("date"),
                ~ anytime::anydate(.x))) %>% 
  ## remove prepended text
  mutate(statusId = sub('.*TYPE_' , '', statusId )) %>%
  ## shorten ids temporarily
  mutate(id = str_pad(as.numeric(as.factor(id)), width = 2, pad = 0)) %>% 
  ## arrange
  arrange(id, dateOfFollowUp) %>% 
  ## fix followups. 14 days of follow-up only 
  group_split(id) %>%   ## for each group
  map(.f = 
        ~ .x %>% 
        ## add sequence from day after last contact to 14 days after
        complete(dateOfFollowUp = seq.Date(dateOfLastContact[1] + 1, 
                                           dateOfLastContact[1] + 14, 
                                           by = '1 days'),
                 fill = list(id = first(.$id), 
                             dateOfLastContact = first(.$dateOfLastContact),
                             statusId = "MISSING")) %>% 
        ## remove NA followups. Artifact of completion
        filter(!is.na(dateOfFollowUp))  %>% 
        ## remove old out-of-range follow-ups. Assume mistaken
        filter(dateOfFollowUp <= (dateOfLastContact + 14) & 
                 dateOfFollowUp > dateOfLastContact )) %>% 
  ## recombine
  bind_rows() %>% 
  ## set followups after today to "FUTURE"
  mutate(statusId = if_else(dateOfFollowUp > todays_date, 
                            "FUTURE FOLLOWUP",
                            statusId
                            )) %>% 
  ## re-sort columns 
  select(id, dateOfLastContact, dateOfFollowUp, statusId) %>% 
  ## final rowcount should be number of ids times 14
  ungroup()
  
```

---
